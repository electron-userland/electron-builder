import * as path from "path"
import * as fs from "fs"
import * as which from "which"
import { execSync } from "child_process"
import { log } from "builder-util"

export enum PM {
  NPM = "npm",
  YARN = "yarn",
  PNPM = "pnpm",
  YARN_BERRY = "yarn-berry",
  BUN = "bun",
}

// Cache for resolved paths
const pmPathCache: Record<PM, string | null | undefined> = {
  [PM.NPM]: undefined,
  [PM.YARN]: undefined,
  [PM.PNPM]: undefined,
  [PM.YARN_BERRY]: undefined,
  [PM.BUN]: undefined,
}

function resolveCommand(pm: PM): string {
  const fallback = pm === PM.YARN_BERRY ? "yarn" : pm

  if (process.platform !== "win32") {
    return fallback
  }

  try {
    return which.sync(fallback)
  } catch {
    // If `which` fails (not found), still return the fallback string
    return fallback
  }
}

export function getPackageManagerCommand(pm: PM) {
  if (pmPathCache[pm] !== undefined) {
    return pmPathCache[pm]!
  }

  const resolved = resolveCommand(pm)
  pmPathCache[pm] = resolved
  return resolved
}

export function detectPackageManagerByEnv(): PM | null {
  const priorityChecklist = [(key: string) => process.env.npm_config_user_agent?.includes(key), (key: string) => process.env.npm_execpath?.includes(key)]

  const pms = Object.values(PM).filter(pm => pm !== PM.YARN_BERRY)
  for (const checker of priorityChecklist) {
    for (const pm of pms) {
      if (checker(pm)) {
        return pm
      }
    }
  }
  return null
}

export function detectPackageManagerByFile(dir: string): PM | null {
  const has = (file: string) => fs.existsSync(path.join(dir, file))

  const detected: PM[] = []
  if (has("yarn.lock")) {
    detected.push(PM.YARN)
  }
  if (has("pnpm-lock.yaml")) {
    detected.push(PM.PNPM)
  }
  if (has("package-lock.json")) {
    detected.push(PM.NPM)
  }
  if (has("bun.lock") || has("bun.lockb")) {
    detected.push(PM.BUN)
  }

  if (detected.length === 1) {
    return detected[0]
  }

  return null
}

export function detectYarnBerry(cwd: string): PM.YARN_BERRY | PM.YARN {
  const lockPath = path.join(cwd, "yarn.lock")
  // Read the first few lines of yarn.lock to determine the version
  const firstBytes = fs.readFileSync(lockPath, "utf8").split("\n").slice(0, 10).join("\n");

  // Yarn v2+ (Berry) has a "__metadata:" block near the top
  if (firstBytes.includes("__metadata:")) {
    return PM.YARN_BERRY
  }

  // Yarn v1 format is classic semi-YAML with comment header
  if (firstBytes.includes("DO NOT EDIT THIS FILE DIRECTLY.")) {
    return PM.YARN
  }

  // fallback to `yarn --version` check since this works AFTER corepack is enabled, but cannot be detected before hand (e.g. unit tests)
  try {
    const version = execSync("yarn --version", { encoding: "utf8", cwd }).toString().trim()
    if (parseInt(version.split(".")[0]) > 1) {
      return PM.YARN_BERRY
    }
  } catch (_error) {
    log.debug({ error: _error }, "cannot determine yarn version, assuming yarn v1")
    // If `yarn` is not found or another error occurs, fall back to the regular Yarn since we're already determined in a Yarn project
  }
  return PM.YARN
}
